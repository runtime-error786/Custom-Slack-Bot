from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from langgraph.graph import StateGraph
from .Crag import custom_graph
import uuid

class AgentAnswerAPIView(APIView):
    """
    API View to handle RAG-based question answering with per-user thread management.
    """
    def post(self, request, *args, **kwargs):
        try:
            # Parse input from request data
            question = request.data.get("question", None)
            print(f"Received question: {question}")  # Print the question from the request
            
            if not question:
                print("Error: 'question' is required but not provided.")  # Print an error message if no question
                return Response(
                    {"error": "Question is required."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Assign or retrieve thread_id for the user's session
            session = request.session
            if not session.get("thread_id"):
                session["thread_id"] = str(uuid.uuid4())
            thread_id = session["thread_id"]
            print(f"Thread ID: {thread_id}")  # Print the thread ID
            
            # Retrieve or initialize conversation history for the thread
            conversation_history = session.get("conversation_history", [])
            print(f"Conversation history: {conversation_history}")  # Print current conversation history
            
            # Append the current question to conversation history
            print("pass 1")
            conversation_history.append({'question': question})
            print("pass 2")
            session["conversation_history"] = conversation_history
            
            # Generate the context by adding past conversations
            print("pass 3")
            context = ""
            for entry in conversation_history:
                if 'question' in entry:
                    context += f"Q: {entry['question']}\n"
                else:
                    print(f"Warning: Missing 'question' key in conversation history entry: {entry}")
            print(f"Context for the custom graph: {context}")  # Print the context generated from conversation history            print("pass 4")
            print(f"Context for the custom graph: {context}")  # Print the context generated from conversation history
            
            # Invoke the custom graph
            print("pass 5")
            config = {"configurable": {"thread_id": thread_id, "context": context}}
            print("pass 6")
            state_dict = custom_graph.invoke({"question": question, "steps": []}, config)
            print("pass 7")
            print(f"State dict returned from custom graph: {state_dict}")  # Print the response from the custom graph
            print("pass 8")
            if 'generation' not in state_dict:
                print("Error: 'generation' key not found in state_dict.")
                return Response({"error": "'generation' key not found in the response from custom graph."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
            print("pass 9")
            # Extract the response and append to the conversation history
            answer = state_dict.get("generation", "")
            print("pass 10")
            print(f"Answer generated: {answer}")  # Print the answer generated by the custom graph
            print("pass 11")
            # Only append the answer after the question is handled
            conversation_history.append({"answer": answer})
            print("pass 12")
            session["conversation_history"] = conversation_history
            print("pass 13")
            response = {
                "response": answer,
                "steps": state_dict.get("steps", []),
            }
            print("pass 14")
            return Response(response, status=status.HTTP_200_OK)

        except Exception as e:
            print(f"Error occurred: {str(e)}")  # Print the error message if an exception occurs
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
